* Overview

A period script, possibly run by timer, which mirrors upstream data as needed.

Optional argument specifies how far back to go, default is 24 hours.

* Application Design

Config has SourceConfigs, described below.

a SourceConfig can be used to construct a Mirror -- if all looks good!

Does it make sense to make Mirror a typestate, e.g, Mirror<STATE> where STATE is:
 - untested
 - ok
 - failing
?  I'm not sure it does, we don't really need to track state.

Capture represents a single mirrored entity.

Mirror methods:
  GetLatest -> Result<Capture>
    grab the latest, if necessary, or else return from local cache
  EnsureSince(Duration) -> Result<CaptureList>
    ensure our local mirror is up to date, going back from now - Duration

TimeRange is (StartSystemTime, EndSystemtime)

We need a number of supporting fuctions.  Start by considering EnsureLatest,
consider a naive implementation that going from more recent to least:
  - p is the period of the Mirror, e.g., 24 hours for a daily mirror
  - t starts as now
  - loop:
    - consider time range (t-p, t)
    - if we have a Capture within that period, collect it
    - take away p from t
    - keep looping while the span from t to now is less than Duration

Capture constructors, these are probably methods on the Mirror:
  CapturesInRange(TimeRange) -> Result<CaptureList>
  CapturesSince(Duration) -> Result<CaptureList>
    - implied now
  LatestCapture() -> Result<Capture>

Maybe this is blue sky but it would also be nice to have a way for the
mirror to qualify the regularity of the source:
  Deviation(Since)


* First pass

We want to capture
https://sdo.gsfc.nasa.gov/assets/img/dailymov/2023/02/20/20230220_1024_0094.ogv

One per day.

A possible TOML file:

#+begin_example
[[source]]
name      = "Solar Data Observatory"
remote	  = "https://sdo.gsfc.nasa.gov/assets/img/dailymov"
local     = "/home/adam/tmp/sat/sdo"
pathmaker = "SDO"
freq      = "Daily"
flatten   = true
#+end_example
